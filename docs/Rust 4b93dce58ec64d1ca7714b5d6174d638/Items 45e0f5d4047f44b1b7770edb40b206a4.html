<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Items</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="45e0f5d4-047f-44b1-b777-0edb40b206a4" class="page sans"><header><h1 class="page-title">Items</h1></header><div class="page-body"><nav id="05cd3264-5a4d-4249-a1c9-873b62387d27" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#878110b4-77e1-4775-b6cb-77cf965ec4d1">Types</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9db39bd5-fb83-4e2c-a96f-0830524c055e">Numeric types</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#849b504e-e2fe-44af-8d07-06b5951a28c2">Textual types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c20955ca-b5c0-4fac-8793-25573d136cf8">1) char</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#46f49317-4836-4d0d-95d8-c8e8c751e226">2) str</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8dd5ca55-2f3a-4320-a327-dbb796573a8b">Boolean</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bf7b5886-0de6-4596-89ef-f261f55d22f6">Sequence types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6dad7dfc-4ccf-40f0-b8b8-d54747b5f25d">1) Tuple</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e68cc094-f93e-43ba-a7ca-7c0c176e3ec4">2) Array</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a0ba4234-38ce-4af3-aba0-8db422de9e6a">3) Slice</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#227c0339-9796-4819-8ff3-8a744d5dbf8b">User-defiend types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0ee12129-89a2-4324-af13-f0278c4126ff">1) struct</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9b771ce1-9a21-4b01-a686-0574c3b632ec">2) enum</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#95958925-d50a-40c4-b3ab-5d894f8d4fee">3) union</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#53b3cceb-0645-4be5-8a36-2510934ceca9">Pointer types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8c5947f5-5b11-4da2-851e-319f951d6575">1) References (&amp; and &amp;mut)</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#1c4f36f0-8bf4-4469-aca1-b16c96733a24">2) Raw pointers (*const and *mut)</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#cea36467-38e3-49a2-96aa-7eb58ae12b45">3) Function pointer</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#38f6205d-0bd8-4155-be95-ffba906013ce">4) Smart pointer</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#210616bc-bf5f-414c-b820-8454adfd72c3">Type casting</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#788f8893-89cd-4b5c-8f9a-d5bb943d5c6b">- From, Into</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f183c69e-76e0-4948-9e6b-f12bc5d1c382">Default</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e65063f0-2a42-4246-a681-6451f92a2dc6">Operators</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9ba150a0-5fbd-4ca7-9058-e15c8f5cacdb">Type checking </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a9f1fe1f-dca5-464b-b26f-cfe5c96cd46f">Type aliasing</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#87f18649-797f-4fd3-bded-83e09b30f58d">Collections</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f641d5e5-0d28-4dc2-8c50-0a29ba44b22a">0) String</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bb741ba4-d3c6-4a91-953c-76add2b54f5f">1) Maps</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#162691a0-f187-4bf1-b63c-7a94092e2443">1-1) HashMap</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#21d9ab1c-9e3e-43aa-8fd7-3fc44ce73d3c">1-2) BTreeMap</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ad8ab972-c507-466c-bfcd-4476b5c5b91c">2) Sequences</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#3e16abe5-fd0c-40db-bcf2-2513e2839ed4">2-1) Vec</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#193bbf0c-8cc9-411d-b10e-a47c21536f20">2-2) VecDequeue</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8ba15dbc-9a18-4db4-aa31-8d9903adb91c">2-3) LinkedList</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#73a8b369-4a68-484a-807d-8cb61ed5ed4f">3) Sets</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2c067d8a-615a-4916-a3c2-69b4cf3f716b">3-1) HashSet</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#fa32444b-6e88-4070-b363-ac0718b8fa1d">3-2) BTreeSet</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fcfb37a8-8979-4bbc-a81c-10944337e362">4) BinaryHeap</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1317fc82-86e0-4b2d-b762-e42f3a229dbf">function</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f9f0395e-b8a5-44a2-bdf6-5f5c46fbec6d">- Closures</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1aab3e07-3d83-454b-9408-fb9c199fc0e6">Iterators</a></div></nav><h1 id="878110b4-77e1-4775-b6cb-77cf965ec4d1" class="">Types</h1><p id="a77cb3de-ea31-4179-891c-6c7600f439aa" class=""><code>let [mut]</code> : local에서 임의의 메모리 주소에 할당. global 선언 불가</p><p id="bbabd1ed-a6b9-4416-ad3d-c3dd04335616" class=""> <code>const</code> : 상수. 대부분의 상황에서 <code>static</code> 대신 사용</p><p id="a1a53cb7-b130-46c0-92a0-176478d83340" class=""><code>static [mut]</code> : 특정 메모리 주소를 고정적으로 점유해서 할당. <code>mut</code> 쓰려면 <code>unsafe</code> 필요
                         c언어에서 보면 함수 안에 static 선언한 변수가 다시 함수 콜 할 때 값 살아있음.</p><p id="cc32766d-e822-494b-9948-f96735d3deec" class="">
</p><ul id="bfcfe01b-b47c-4eeb-8985-02874a7ca59e" class="bulleted-list"><li><code>const</code><strong> </strong>declare <em>constant values</em>. These represent a value, not a memory address. This is the most common thing one would reach for and would replace <code>static</code> as we know it today in almost all cases.</li></ul><ul id="166aeec7-cbbb-48b2-8fab-4954e5b72d22" class="bulleted-list"><li><code>static</code><strong> </strong>declare <em>global variables</em>. These represent a memory address. They would be rarely used: the primary use cases are global locks, global atomic counters, and interfacing with legacy C libraries.</li></ul><p id="4b9ae516-e43a-4978-bfb2-5d762746d891" class="">
</p><p id="9b87e8ca-f102-4681-8a7f-f7894a6bc724" class="">아래처럼 <code>let</code>은 앞에 값을 가져오면서 재선언할 수 있는데 이를 <em>shadowing</em>이라고 함.
<code>const</code>는 무조건 한번만 선언 가능.</p><pre id="b6cd0eb8-e29d-47fd-a829-8799e1d87091" class="code"><code>const MAX_POINTS: u32 = 100_000;

fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}</code></pre><p id="f93e40c7-8d24-40d1-a962-fe0647c2d0d9" class=""><code>mut</code>을 사용할 때랑 다른 점은 <code>mut</code>은 같은 타입에서만 값 변경 가능</p><pre id="761b29c7-9275-4433-a7c7-c5de09b1514d" class="code"><code>// 가능
fn main() {
    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
}

// 불가능
fn main() {
    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
}</code></pre><h2 id="9db39bd5-fb83-4e2c-a96f-0830524c055e" class="">Numeric types</h2><p id="8d69a967-dc6d-41a7-a76e-f95e043f8de5" class="">primitive data type</p><div id="5691b845-d3d6-4a0e-bb70-3136d46c4d8c" class="column-list"><div id="bc66f401-a7f3-4264-a096-6fdec50fd9ca" style="width:50%" class="column"><figure id="addbfa64-e563-4ea6-b7d1-fc8f90720761" class="image"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled.png"><img style="width:406px" src="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled.png"/></a></figure></div><div id="4ac652c2-0fd7-4a62-84a8-54c34bb93313" style="width:50%" class="column"><figure id="1ee30359-7dd3-4f1f-93d3-a2811e53ddd9" class="image"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%201.png"><img style="width:414px" src="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%201.png"/></a></figure></div></div><p id="fff69c23-7e5d-43e6-8c67-a3b4096a037d" class="">Floating-point types : <code>f32</code>, <code>f64</code></p><p id="5f33ac7a-521c-4e9b-aea8-c1b591e190f7" class="">별다른 말 없으면 소수는 <code>f64</code>, 정수는 <code>u32</code>로 선언됨</p><pre id="9f165c70-7fbd-45d1-afd1-d08cc93630eb" class="code"><code>use std::mem::{size_of, size_of_val};

fn main() {
    // Suffixed literals, their types are known at initialization
    let x: u8 = 1;
    let y = 2u32;
    let z: f32 = 3.0;

    // Unsuffixed literals, their types depend on how they are used
    let i = 1;
    let f = 1.0;

    println!(&quot;size of `x` in bytes: {}&quot;, size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, size_of_val(&amp;f));
    println!(&quot;size of isize in bytes: {}&quot;, size_of::&lt;isize&gt;());
    println!(&quot;size of usize in bytes: {}&quot;, size_of::&lt;usize&gt;());
}</code></pre><p id="e14ce9ae-1cc9-40e3-86a0-a5a8190f6b7f" class="">
</p><h2 id="849b504e-e2fe-44af-8d07-06b5951a28c2" class="">Textual types</h2><p id="27211c43-2bd0-4e5d-9ddb-8d9bd1004cb8" class="">primitive data type</p><h3 id="c20955ca-b5c0-4fac-8793-25573d136cf8" class="">1) char</h3><p id="7f6c8d3d-758b-4482-bb74-d515be399623" class="">Unicode scalar value (i.e. a code point that is not a surrogate), represented as a <strong>32-bit unsigned</strong> word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range.</p><h3 id="46f49317-4836-4d0d-95d8-c8e8c751e226" class="">2) str</h3><p id="2aa98e46-26d6-4265-8f08-e869d6ccb1e8" class="">[u8], it is a <strong>slice of 8-bit unsigned bytes,</strong> <strong>UTF-8
→ </strong><code>&amp;str</code> 형태로 호출됨, immutable</p><figure id="cf20a17e-e2ac-4773-9378-3e89a5f11841" class="image"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%202.png"><img style="width:563px" src="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%202.png"/></a></figure><pre id="7c833876-930c-445a-a91a-e8f430cb9063" class="code"><code>let a = &quot;abcde&quot;;
let b = &amp;a[2..];       // &amp;a[..], &amp;a[..5]
let hello = &quot;Здравствуйте&quot;;
let s = &amp;hello[0..4];
  
println!(&quot;{} {}&quot;, a, b);   // cde
println!(&quot;{}&quot;, s);         // Зд</code></pre><p id="285a3d28-8a43-4ff6-a578-7d569069f082" class="">위에서 보았듯이 인덱싱하면 글자단위로 짜르는 게 아니라 바이트 단위로 짜르므로 주의가 필요.</p><p id="927d1e4f-4611-4a14-99f7-eb7dfee6bb7e" class="">
</p><p id="1b62195f-cb8a-447c-b5ee-a55a5a4ae8f6" class="">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]  <mark class="highlight-red_background">grapheme clusters</mark>
→ [&#x27;न&#x27;, &#x27;म&#x27;, &#x27;स&#x27;, &#x27;्&#x27;, &#x27;त&#x27;, &#x27;े&#x27;] <mark class="highlight-red_background">char (unicode)</mark>  4, 6번째는 발음 구별 부호
→ [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]  <mark class="highlight-red_background">u8</mark></p><h2 id="8dd5ca55-2f3a-4320-a327-dbb796573a8b" class="">Boolean</h2><p id="eb798264-cd58-47fd-91af-08841496cdbe" class="">primitive data type</p><pre id="6413086f-8ec5-4ba6-8b3a-9d3a440724ec" class="code"><code>let b: bool = true;</code></pre><h2 id="bf7b5886-0de6-4596-89ef-f261f55d22f6" class="">Sequence types</h2><p id="f5beadc1-54b9-465c-a392-128ca880708b" class="">stack memory에 저장. 즉 데이터의 크기를 컴파일 시점에 알 수 있고 런타임에서 크기 증가시키거나 감소시키는 것 이 불가함.</p><h3 id="6dad7dfc-4ccf-40f0-b8b8-d54747b5f25d" class="">1) Tuple</h3><p id="804feb06-8891-403e-91f4-739538db3473" class="">고정된 길이를 가지며 한 번 정의하면 그 크기를 키우거나 줄일 수 없다.</p><p id="a7f70fe5-c26a-4d16-b917-b88bbc6aa256" class="">여러가지 data type을 한 tuple에 저장 가능</p><pre id="2412b20c-68bf-44f4-9826-ae5f7d24a7b8" class="code"><code>// Tuples can be used as function arguments and as return values
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {

    let (integer, boolean) = pair;

    (boolean, integer)
}

// The following struct is for the activity.
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {

    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      &#x27;a&#x27;, true);

    // Values can be extracted from the tuple using tuple indexing
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);

    // Tuples can be tuple members
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);
    
    // But long Tuples cannot be printed, up to 12 items
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);


    let pair = (1, true);
    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // To create one element tuples, the comma is required to tell them apart
    // from a literal surrounded by parentheses
    println!(&quot;one element tuple: {:?}&quot;, (5u32,));
    println!(&quot;just an integer: {:?}&quot;, (5u32));

    //tuples can be destructured to create bindings
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}</code></pre><h3 id="e68cc094-f93e-43ba-a7ca-7c0c176e3ec4" class="">2) Array</h3><p id="a5bd8250-531f-4b22-a70e-599936d434a6" class=""><code>Tuple</code>과 달리 각 요소는 반드시 같은 타입이어야 하고 고정된 길이.
가변적인 개수의 요소를 다루고 싶으면 <code>Vector</code> 사용</p><pre id="dc669e6e-e64b-4e52-b504-06ff9367405f" class="code"><code>use std::mem;

// This function borrows a slice
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    let xs: [i32; 5] = [1, 2, 3, 4, 5];
    println!(&quot;number of elements in array: {}&quot;, xs.len());

    // Arrays are stack allocated
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // All elements can be initialized to the same value
    let ys: [i32; 500] = [0; 500];

    // Arrays can be automatically borrowed as slices
    // Slices can point to a section of an array
    analyze_slice(&amp;xs);
    analyze_slice(&amp;xs[1..4]);

}</code></pre><h3 id="a0ba4234-38ce-4af3-aba0-8db422de9e6a" class="">3) Slice</h3><pre id="ce74a7ac-a82c-407e-b262-d31e31f77f21" class="code"><code>assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });
assert_eq!(3 + 4 + 5, (3..6).sum());

let arr = [0, 1, 2, 3, 4];
assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);
assert_eq!(arr[ .. 3], [0, 1, 2      ]);
assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);
assert_eq!(arr[1..  ], [   1, 2, 3, 4]);
assert_eq!(arr[1.. 3], [   1, 2      ]); // This is a `Range`
assert_eq!(arr[1..=3], [   1, 2, 3   ]);</code></pre><h2 id="227c0339-9796-4819-8ff3-8a744d5dbf8b" class="">User-defiend types</h2><h3 id="0ee12129-89a2-4324-af13-f0278c4126ff" class="">1) struct</h3><pre id="be894a7a-3011-4feb-bbf8-19defeaf77d1" class="code"><code>let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);</code></pre><figure id="9e1b6262-1bad-4c7a-8ae6-00e2534a25e4" class="link-to-page"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/example%209e1b62621bad4c7a8ae600e2534a25e4.html">example</a></figure><h3 id="9b771ce1-9a21-4b01-a686-0574c3b632ec" class="">2) enum</h3><pre id="ebf85273-3820-4acb-b7a9-b567b4f48ee6" class="code"><code>enum WebEvent {
    PageLoad,
    PageUnload,
    KeyPress(char),
    Paste(String),
    Click { x: i64, y: i64 },
}

fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // Destructure `c` from inside the `enum`.
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed &#x27;{}&#x27;.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress(&#x27;x&#x27;);
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste(String::from(&quot;my text&quot;));
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}</code></pre><h3 id="95958925-d50a-40c4-b3ab-5d894f8d4fee" class="">3) union</h3><p id="ee2eb67a-1cc3-41d4-8742-2c15150b19da" class="">The key property of <code>union</code>s is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</p><p id="48121e4c-804e-4f07-ae67-504e30d0e399" class="">Consequently, all reads of union fields have to be placed in <code>unsafe</code> blocks:</p><pre id="d2c2cd4d-6fe4-4067-b885-cbad8755d961" class="code"><code>fn main() {
union MyUnion { f1: u32, f2: f32 }

    let mut u = MyUnion { f1: 1 };
    unsafe {
        println!(&quot;{}&quot;, u.f1);
        let b1 = &amp;mut u.f1;

//                    ---- first mutable borrow occurs here (via `u.f1`)
//         let b2 = &amp;mut u.f2;
// //                    ^^^^ second mutable borrow occurs here (via `u.f2`)
// // ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time
        *b1 = 5;


    }
//  - first borrow ends here
    assert_eq!(unsafe { u.f1 }, 5);

}</code></pre><h2 id="53b3cceb-0645-4be5-8a36-2510934ceca9" class="">Pointer types</h2><h3 id="8c5947f5-5b11-4da2-851e-319f951d6575" class="">1) References (&amp; and &amp;mut)</h3><p id="c7f43cb1-4f77-4c7f-8cb7-9831e5fff924" class="">These point to memory owned by some other value.</p><figure id="5569f4f3-da25-436e-b722-a6d55cbf7322" class="image"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%203.png"><img style="width:288px" src="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%203.png"/></a></figure><h3 id="1c4f36f0-8bf4-4469-aca1-b16c96733a24" class="">2) Raw pointers (*const and *mut)</h3><p id="97e125a2-52b9-4930-b024-233a50711319" class="">Raw pointers are pointers without safety or liveness guarantees.
Raw pointers are generally discouraged in Rust code</p><figure id="7a24fefc-9afb-4ada-a565-5278bee202a3" class="image"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%204.png"><img style="width:288px" src="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%204.png"/></a></figure><h3 id="cea36467-38e3-49a2-96aa-7eb58ae12b45" class="">3) Function pointer</h3><p id="03161940-250c-48d8-86b0-47ac96a67f0f" class="">Function pointer types, written using the <code>fn</code> keyword, refer to a function whose identity is not necessarily known at compile-time.</p><pre id="0b76a18e-6235-4bb4-9f9e-5fa27a1d4654" class="code"><code>fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32; // Binop is defined as a function pointer
let bo: Binop = add;
x = bo(5,7);</code></pre><h3 id="38f6205d-0bd8-4155-be95-ffba906013ce" class="">4) Smart pointer</h3><figure id="6b4faec8-35bf-4da2-ba56-f77ef4dad1b4" class="link-to-page"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Smart%20pointer%206b4faec835bf4da2ba56f77ef4dad1b4.html">Smart pointer</a></figure><h2 id="210616bc-bf5f-414c-b820-8454adfd72c3" class="">Type casting</h2><p id="c9048668-ce68-49f4-9c45-49062693da4a" class="">타입 변환</p><figure id="6e918174-7f1b-43b0-ac6f-8e1bb02aa702" class="image"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%205.png"><img style="width:1039px" src="Items%2045e0f5d4047f44b1b7770edb40b206a4/Untitled%205.png"/></a></figure><pre id="2b36aaf9-8e9e-4de3-9598-60bba722f4d9" class="code"><code>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;  // 정수로 못 나누니까 실수로 type casting
    sum / size
}</code></pre><h3 id="788f8893-89cd-4b5c-8f9a-d5bb943d5c6b" class="">- From, Into</h3><pre id="9b5f92e2-677a-490d-9ce6-b90c2e150f2b" class="code"><code>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);</code></pre><pre id="d65b4c02-4f94-4ed7-9d56-b7b5f2981b77" class="code"><code>// Define custom &quot;from&quot;

use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre><p id="2afbe575-7438-480a-aa36-5cbcad4f78f2" class="">
</p><p id="dc091681-c6a5-4880-bbd2-647ea881ed0f" class=""><code>Into</code> trait은 <code>From</code> trait이 구현된 곳에서 자동으로 사용 가능</p><pre id="a3b6243d-9232-48f9-b421-aed60a627be9" class="code"><code>use std::convert::From;

#[derive(Debug)]
struct MyNumber {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}</code></pre><h2 id="f183c69e-76e0-4948-9e6b-f12bc5d1c382" class="">Default</h2><p id="68635779-efd6-4742-b0ce-faaf8abdbb36" class=""><strong>Built-in default value</strong></p><pre id="b9869fad-add7-4bf9-a1be-7ffdf87ec1e1" class="code"><code>#[derive(Default)]
struct DefaultSet {
    a: i32,
    b: f32,
    c: u32,
    d: bool,
}
fn main() {
let test = DefaultSet { ..Default::default() };
let (x, y): (Option&lt;String&gt;, f64) = Default::default();
println!(&quot;{:?} {:?} {}&quot;, test, x, y);
}</code></pre><p id="11488312-58bc-42bf-82e0-313c6e3818dc" class=""><strong>Custom default value</strong></p><pre id="228d3acc-ff09-4893-a473-c65057c3dc4e" class="code"><code>#[derive(Debug)]
struct SomeOptions {
    foo: i32,
    bar: f32,
}

impl Default for SomeOptions {
    fn default() -&gt; SomeOptions { SomeOptions{ foo: 10, bar: 30.03}}
}

#[derive(Debug)]
enum Kind {
    A,
    B,
    C,
}

impl Default for Kind {
    fn default() -&gt; Self { Kind::A }
}

fn main() {
    let options: SomeOptions = Default::default();
    let mykind: Kind = Default::default();
    println!(&quot;{:?} {:?} {:?} {}&quot;, options, mykind, Kind::B, Kind::C as u32);
}</code></pre><h2 id="e65063f0-2a42-4246-a681-6451f92a2dc6" class="">Operators</h2><pre id="63ea394c-c0b3-4e25-a7d3-ed8ac2f683b3" class="code"><code>fn main() {
    // Integer addition
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // Integer subtraction
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important

    // Short-circuiting boolean logic
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // Use underscores to improve readability!
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}</code></pre><h2 id="9ba150a0-5fbd-4ca7-9058-e15c8f5cacdb" class="">Type checking </h2><p id="819f5c3c-6bb0-4313-a8b0-479a40633cc4" class="">아직 nightly version에만 적용됨</p><pre id="1af72a39-7061-42ce-85d3-520f1de136be" class="code"><code>#![feature(type_name_of_val)]
fn main() {
use std::any::type_name_of_val;

let x = 1;
println!(&quot;{}&quot;, type_name_of_val(&amp;x));
let y = 1.0;
println!(&quot;{}&quot;, type_name_of_val(&amp;y));
}</code></pre><p id="0cf020b6-d8d5-4185-8cfc-e41e2209957a" class="">또는 stable에서 아래처럼 직접 정의해서 사용도 가능</p><pre id="645f62a6-b3bf-41cc-a623-39dfb42cb58c" class="code"><code>use std::any::type_name;

fn type_name_of_val&lt;T: ?Sized&gt;(_val: &amp;T) -&gt; &amp;&#x27;static str {
    type_name::&lt;T&gt;()
}</code></pre><h2 id="a9f1fe1f-dca5-464b-b26f-cfe5c96cd46f" class="">Type aliasing</h2><pre id="bfef080f-a8b9-43d5-9bc7-94f3d31d6495" class="code"><code>fn main() {
type Point = (u8, u8);
let p: Point = (41, 68);
}</code></pre><pre id="1f99c129-d355-4171-b301-0ac8da9108a2" class="code"><code>fn main() {
struct MyStruct {
 a: u32
};

use MyStruct as UseAlias;
type TypeAlias = MyStruct;
type kilometers = i32;
 
let _ = UseAlias{ a: 4 };
let _ = TypeAlias{ a: 10 };
}</code></pre><h1 id="87f18649-797f-4fd3-bded-83e09b30f58d" class="">Collections</h1><p id="27a675f0-9b2f-42b0-bf2e-5ff4a53d5610" class=""><em>Heap</em>에 저장</p><p id="91939639-0d9b-479f-b100-b9cb8c67b99e" class=""><code>std::collections</code></p><ul id="8aecc8c3-0180-4822-a215-fb39e918e55b" class="bulleted-list"><li>Sequences: <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a></li></ul><ul id="fe02cc5c-c6e0-4785-b6de-92832dd598aa" class="bulleted-list"><li>Maps: <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html"><code>HashMap</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a></li></ul><ul id="ea57989d-e91a-4c00-862c-0437a8a1d9a8" class="bulleted-list"><li>Sets: <a href="https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a></li></ul><ul id="927e9a12-781b-45b5-ad87-73eaf4dfee59" class="bulleted-list"><li>Misc: <a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a></li></ul><h2 id="f641d5e5-0d28-4dc2-8c50-0a29ba44b22a" class="">0) String</h2><p id="c1157fb6-a374-450d-a5ac-ec24c295ec27" class="">A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code></p><p id="b3aae8f5-8d52-4c53-a264-c033f3422d55" class="">UTF-8 Encoding, mutable string type</p><pre id="0d546558-51d2-4400-89d7-ff2d002271bb" class="code"><code>let s1 = &quot;string_slice&amp;&quot;.to_string();
let s2 = String::from(&quot;&amp;string_slice2&quot;);

// Extracts a string slice containing the entire String
let s3 = &amp;s1;
let s4 = s2.as_str();</code></pre><pre id="e7deec68-0321-4fb4-bd85-2c66ea0685a5" class="code"><code>fn modify_word(s: &amp;mut String) -&gt; &amp;str {

    s.push_str(&quot;, LJS&quot;);
    &amp;s[..2]
}

fn main() {
    let mut my_string = String::from(&quot;hello world&quot;);

    let word = modify_word(&amp;mut my_string);
    
    println!(&quot;{}&quot;, word);       // he
    println!(&quot;{}&quot;, my_string);  // hello world, LJS

}</code></pre><h2 id="bb741ba4-d3c6-4a91-953c-76add2b54f5f" class="">1) Maps</h2><h3 id="162691a0-f187-4bf1-b63c-7a94092e2443" class="">1-1) HashMap</h3><pre id="b92b6ac9-8a78-4b4c-9bc2-f135541d88d6" class="code"><code>use std::collections::HashMap;

#[derive(Debug)]
enum Value {
    Str(&amp;&#x27;static str),
    Int(i32),
}

fn main() {
    let mut map = HashMap::new();

    map.insert(&quot;a&quot;, Value::Str(&quot;1&quot;));
    map.insert(&quot;b&quot;, Value::Int(2));
		
    assert_eq!(map.contains_key(&quot;a&quot;), true);
    assert_eq!(map.len(), 2);

	for (key, val) in map.iter() {
	    println!(&quot;key: {} val: {:?}&quot;, key, val);
	}
	for key in map.keys() {
	    println!(&quot;{}&quot;, key);
	}
}</code></pre><h3 id="21d9ab1c-9e3e-43aa-8fd7-3fc44ce73d3c" class="">1-2) BTreeMap</h3><h2 id="ad8ab972-c507-466c-bfcd-4476b5c5b91c" class="">2) Sequences</h2><h3 id="3e16abe5-fd0c-40db-bcf2-2513e2839ed4" class="">2-1) Vec</h3><pre id="9893502b-3560-474f-8416-adb684e26df2" class="code"><code></code></pre><h3 id="193bbf0c-8cc9-411d-b10e-a47c21536f20" class="">2-2) VecDequeue</h3><h3 id="8ba15dbc-9a18-4db4-aa31-8d9903adb91c" class="">2-3) LinkedList</h3><h2 id="73a8b369-4a68-484a-807d-8cb61ed5ed4f" class="">3) Sets</h2><h3 id="2c067d8a-615a-4916-a3c2-69b4cf3f716b" class="">3-1) HashSet</h3><h3 id="fa32444b-6e88-4070-b363-ac0718b8fa1d" class="">3-2) BTreeSet</h3><h2 id="fcfb37a8-8979-4bbc-a81c-10944337e362" class="">4) BinaryHeap</h2><h1 id="1317fc82-86e0-4b2d-b762-e42f3a229dbf" class="">function</h1><figure id="db2f362a-3a14-4bac-8383-8aade020ea86" class="link-to-page"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/function%20examples%20db2f362a3a144bac83838aade020ea86.html">function examples</a></figure><h2 id="f9f0395e-b8a5-44a2-bdf6-5f5c46fbec6d" class="">- Closures</h2><p id="5aea1e26-f29c-47f5-8078-6d220c8db65e" class=""><code>|val| val + x</code></p><p id="178c1015-783a-47e4-b38c-bf02be09b6f0" class="">익명함수 형태이고 <code>static</code>이나 <code>const</code>로 선언한 global variable이 아니면서 parameter로 받지 않은 외부 변수를 끌어올 수 있다.</p><pre id="449d109e-316b-4548-bbfe-488dd403317b" class="code"><code>fn main() {

    let i = 1;
    let j = 3;

    fn function(i: i32) -&gt; i32 { i + 1 }
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = || j + 1;


    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred());
}</code></pre><figure id="5f107164-422c-435d-9dfe-1eac02767461" class="link-to-page"><a href="Items%2045e0f5d4047f44b1b7770edb40b206a4/example%205f107164422c435d9dfe1eac02767461.html">example</a></figure><h1 id="1aab3e07-3d83-454b-9408-fb9c199fc0e6" class="">Iterators</h1></div></article></body></html>